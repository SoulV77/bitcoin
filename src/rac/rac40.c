/*  Copyright (C) 2010-2010  Jon Sneyers & Pieter Wuille

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 Parts of this code are based on code from the FFMPEG project, in
 particular:
 - rangecoder.c - Copyright (c) 2004 Michael Niedermayer <michaelni@gmx.at>
 - ffv1.c - Copyright (c) 2004 Michael Niedermayer <michaelni@gmx.at>
 */

#define _BSD_SOURCE 1
#define _POSIX_C_SOURCE 199309

#include <stdlib.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>

#include "rac40.h"

#define MAX_RANGE_BITS 40
#define MIN_RANGE_BITS (MAX_RANGE_BITS-8)
#define MIN_RANGE (1ULL << (rac40_t)(MIN_RANGE_BITS))

#define BASE_RANGE (1ULL << MAX_RANGE_BITS)

void rac40_init_enc(rac40_ctx_t *ctx, void(*writefn)(void *, int), void *data) {
  ctx->range = BASE_RANGE;
  ctx->low = 0;
  ctx->delayed_byte = -1;
  ctx->delayed_count = 0;
  ctx->writefn = writefn;
  ctx->readfn = NULL;
  ctx->data = data;
}

void rac40_init_dec(rac40_ctx_t *ctx, int(*readfn)(void *), void *data) {
  ctx->low = 0;
  rac40_t r = BASE_RANGE;
  while (r > 1) {
    ctx->low <<= 8;
    ctx->low |= readfn(data);
    r >>= 8;
  }
  ctx->range = BASE_RANGE;
  ctx->readfn = readfn;
  ctx->writefn = NULL;
  ctx->data = data;
}

void static inline rac40_read(rac40_ctx_t *ctx) {
  while (ctx->range <= MIN_RANGE) {
    ctx->low <<= 8;
    ctx->range <<= 8;
    ctx->low |= ctx->readfn(ctx->data);
  }
}

void static inline rac40_write(rac40_ctx_t *ctx) {
  while (ctx->range <= MIN_RANGE) {
    int byte = ctx->low >> MIN_RANGE_BITS;
    if (ctx->delayed_byte < 0) { // first generated byte
      ctx->delayed_byte = byte;
    } else if (((ctx->low + ctx->range) >> 8) < MIN_RANGE) { // definitely no overflow
      ctx->writefn(ctx->data,ctx->delayed_byte);
      while (ctx->delayed_count) {
        ctx->writefn(ctx->data,0xFF);
        ctx->delayed_count--;
      }
      ctx->delayed_byte = byte;
    } else if ((ctx->low >> 8) >= MIN_RANGE) { // definitely overflow
      ctx->writefn(ctx->data,ctx->delayed_byte + 1);
      while (ctx->delayed_count) {
        ctx->writefn(ctx->data,0x00);
        ctx->delayed_count--;
      }
      ctx->delayed_byte = byte & 0xFF;
    } else { // possibly overflow
      ctx->delayed_count++;
    }
    ctx->low = (ctx->low & (MIN_RANGE - 1)) << 8;
    ctx->range <<= 8;
  }
}

#define put_bit(ctx,chs,val) { \
  assert(chs>0); \
  assert(chs < ctx->range); \
  if (val) { \
    ctx->low += ctx->range - chs; \
    ctx->range = chs; \
  } else { \
    ctx->range -= chs; \
  } \
  rac40_write(ctx); \
}

#define get_bit(ctx,chs) { \
  assert(chs>0); \
  assert(chs < ctx->range); \
  if (ctx->low >= ctx->range - chs) { \
    ctx->low -= ctx->range - chs; \
    ctx->range = chs; \
    rac40_read(ctx); \
    return 1; \
  } else { \
    ctx->range -= chs; \
    rac40_read(ctx); \
    return 0; \
  } \
}

void inline rac40_put_bit_frac(rac40_ctx_t *ctx, int num, int denom, int value) {
  assert(num>=0);
  assert(num<denom);
  assert(denom>1);
  rac40_t chs = (ctx->range * num + denom / 2) / denom;
  put_bit(ctx,chs,value);
}

void inline rac40_put_bit_b16(rac40_ctx_t *ctx, uint16_t b16, int value) {
  rac40_t chs = (ctx->range * b16 + 0x8000) >> 16;
  put_bit(ctx,chs,value);
}

int inline rac40_get_bit_frac(rac40_ctx_t *ctx, int num, int denom) {
  assert(num>=0);
  assert(num<denom);
  assert(denom>1);
  rac40_t chs = (ctx->range * num + denom / 2) / denom;
  get_bit(ctx,chs);
}

int inline rac40_get_bit_b16(rac40_ctx_t *ctx, uint16_t b16) {
  rac40_t chs = (ctx->range * b16 + 0x8000) >> 16;
  get_bit(ctx,chs);
}

void rac40_flush(rac40_ctx_t *ctx) {
  ctx->low += (MIN_RANGE - 1);
  ctx->range = (MIN_RANGE - 1);
  rac40_write(ctx);
  ctx->range = (MIN_RANGE - 1);
  rac40_write(ctx);
  rac40_init_enc(ctx,ctx->writefn,ctx->data);
}
